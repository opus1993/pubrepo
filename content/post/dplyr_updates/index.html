---
title: "Ten Tidyverse Updates"
author: "Jim Gruman"
date: "2020-09-01"
diagram: true
output: 
 blogdown::html_page:
  toc: false
categories: [Data Science, R]
description: "Stay up to date with examples using the penguins dataset" 
# Featured image
# To use, add an image named `featured.jpg/png` to your page's folder.
# Focal points: Smart, Center, TopLeft, Top, TopRight, Left, Right, BottomLeft, Bottom, BottomRight.
image: 
  caption: ''
  focal_point: "Smart"
  preview_only: false
featured: false
draft: false
---



<p>There is no doubt that the <code>tidyverse</code> opinionated collection of R packages offers attractive, intuitive ways of wrangling data for data science. In earlier versions of <code>tidyverse</code> some elements of user control were sacrificed in favor of simplifying functions that could be picked up and easily used by rookies. In the 2020 updates to <code>dplyr</code> and <code>tidyr</code> there has been progress to restoring some finer control.</p>
<p>This means that there are new methods available in the <code>tidyverse</code> that some may not be aware of. The methods allow you to better transform your data directly to the way you want and to perform operations more flexibly. They also provide new ways to perform common tasks like nesting, modeling and graphing in ways where the code is more readable. Often users are only just scratching the surface of what can be done with the latest updates to this important set of packages.</p>
<p>It’s incumbent on any analyst to stay up to date with new methods. This post covers ten examples of approaches to common data tasks that are better served by the latest <code>tidyverse</code> updates. We will use the new Palmer Penguins dataset, a great all round dataset for illustrating data wrangling.</p>
<p>First let’s load our <code>tidyverse</code> packages and the Palmer Penguins dataset and take a quick look at it. Please be sure to install the latest versions of these packages before trying to replicate the work here.</p>
<pre class="r"><code>library(tidyverse)
library(palmerpenguins)

penguins &lt;-palmerpenguins::penguins  %&gt;%
           filter(!is.na(bill_length_mm))

penguins</code></pre>
<pre><code>## # A tibble: 342 x 8
##    species island bill_length_mm bill_depth_mm flipper_length_~ body_mass_g
##    &lt;fct&gt;   &lt;fct&gt;           &lt;dbl&gt;         &lt;dbl&gt;            &lt;int&gt;       &lt;int&gt;
##  1 Adelie  Torge~           39.1          18.7              181        3750
##  2 Adelie  Torge~           39.5          17.4              186        3800
##  3 Adelie  Torge~           40.3          18                195        3250
##  4 Adelie  Torge~           36.7          19.3              193        3450
##  5 Adelie  Torge~           39.3          20.6              190        3650
##  6 Adelie  Torge~           38.9          17.8              181        3625
##  7 Adelie  Torge~           39.2          19.6              195        4675
##  8 Adelie  Torge~           34.1          18.1              193        3475
##  9 Adelie  Torge~           42            20.2              190        4250
## 10 Adelie  Torge~           37.8          17.1              186        3300
## # ... with 332 more rows, and 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;</code></pre>
<p>The dataset presents several observations of anatomical parts of penguins of different species, sexes and locations, and the year that the measurements were taken.</p>
<div id="selecting-columns" class="section level2">
<h2>1. Selecting columns</h2>
<p><code>tidyselect</code> helper functions are now built in to allow you to save time by selecting columns using <code>dplyr::select()</code> based on common conditions. In this case, if we want to reduce the dataset to just bill measurements we can use this, noting that all measurement columns contain an underscore:</p>
<pre class="r"><code>penguins %&gt;% 
  dplyr::select(!contains(&quot;_&quot;), starts_with(&quot;bill&quot;))</code></pre>
<pre><code>## # A tibble: 342 x 6
##    species island    sex     year bill_length_mm bill_depth_mm
##    &lt;fct&gt;   &lt;fct&gt;     &lt;fct&gt;  &lt;int&gt;          &lt;dbl&gt;         &lt;dbl&gt;
##  1 Adelie  Torgersen male    2007           39.1          18.7
##  2 Adelie  Torgersen female  2007           39.5          17.4
##  3 Adelie  Torgersen female  2007           40.3          18  
##  4 Adelie  Torgersen female  2007           36.7          19.3
##  5 Adelie  Torgersen male    2007           39.3          20.6
##  6 Adelie  Torgersen female  2007           38.9          17.8
##  7 Adelie  Torgersen male    2007           39.2          19.6
##  8 Adelie  Torgersen &lt;NA&gt;    2007           34.1          18.1
##  9 Adelie  Torgersen &lt;NA&gt;    2007           42            20.2
## 10 Adelie  Torgersen &lt;NA&gt;    2007           37.8          17.1
## # ... with 332 more rows</code></pre>
<p>A full set of <code>tidyselect</code> helper functions can be found in the documentation <a href="https://cran.r-project.org/web/packages/tidyselect/tidyselect.pdf">here</a>.</p>
</div>
<div id="reordering-columns" class="section level2">
<h2>2. Reordering columns</h2>
<p><code>dplyr::relocate()</code> allows a new way to reorder specific columns or sets of columns. For example, if we want to make sure that all of the measurement columns are at the end of the dataset, we can use this, noting that my last column is year:</p>
<pre class="r"><code>penguins &lt;- penguins %&gt;% 
  dplyr::relocate(contains(&quot;_&quot;), .after = year)

penguins</code></pre>
<pre><code>## # A tibble: 342 x 8
##    species island sex    year bill_length_mm bill_depth_mm flipper_length_~
##    &lt;fct&gt;   &lt;fct&gt;  &lt;fct&gt; &lt;int&gt;          &lt;dbl&gt;         &lt;dbl&gt;            &lt;int&gt;
##  1 Adelie  Torge~ male   2007           39.1          18.7              181
##  2 Adelie  Torge~ fema~  2007           39.5          17.4              186
##  3 Adelie  Torge~ fema~  2007           40.3          18                195
##  4 Adelie  Torge~ fema~  2007           36.7          19.3              193
##  5 Adelie  Torge~ male   2007           39.3          20.6              190
##  6 Adelie  Torge~ fema~  2007           38.9          17.8              181
##  7 Adelie  Torge~ male   2007           39.2          19.6              195
##  8 Adelie  Torge~ &lt;NA&gt;   2007           34.1          18.1              193
##  9 Adelie  Torge~ &lt;NA&gt;   2007           42            20.2              190
## 10 Adelie  Torge~ &lt;NA&gt;   2007           37.8          17.1              186
## # ... with 332 more rows, and 1 more variable: body_mass_g &lt;int&gt;</code></pre>
<p>Similar to <code>.after</code> you can also use <code>.before</code> as an argument here.</p>
</div>
<div id="controlling-mutated-column-locations" class="section level2">
<h2>3. Controlling mutated column locations</h2>
<p>Note in the <code>penguins</code> dataset that there are no unique identifiers for each study group. This can be problematic when we have multiple penguins of the same species, island, sex and year in the dataset. To address this and prepare for later examples, let’s add a unique identifier using <code>dplyr::mutate()</code>, and here we can illustrate how <code>mutate()</code> now allows us to position our new column in a similar way to <code>relocate()</code>:</p>
<pre class="r"><code>penguins_id &lt;- penguins %&gt;% 
  dplyr::group_by(species, island, sex, year) %&gt;% 
  dplyr::mutate(studygroupid = row_number(), .before = contains(&quot;_&quot;))

penguins_id</code></pre>
<pre><code>## # A tibble: 342 x 9
## # Groups:   species, island, sex, year [35]
##    species island sex    year studygroupid bill_length_mm bill_depth_mm
##    &lt;fct&gt;   &lt;fct&gt;  &lt;fct&gt; &lt;int&gt;        &lt;int&gt;          &lt;dbl&gt;         &lt;dbl&gt;
##  1 Adelie  Torge~ male   2007            1           39.1          18.7
##  2 Adelie  Torge~ fema~  2007            1           39.5          17.4
##  3 Adelie  Torge~ fema~  2007            2           40.3          18  
##  4 Adelie  Torge~ fema~  2007            3           36.7          19.3
##  5 Adelie  Torge~ male   2007            2           39.3          20.6
##  6 Adelie  Torge~ fema~  2007            4           38.9          17.8
##  7 Adelie  Torge~ male   2007            3           39.2          19.6
##  8 Adelie  Torge~ &lt;NA&gt;   2007            1           34.1          18.1
##  9 Adelie  Torge~ &lt;NA&gt;   2007            2           42            20.2
## 10 Adelie  Torge~ &lt;NA&gt;   2007            3           37.8          17.1
## # ... with 332 more rows, and 2 more variables: flipper_length_mm &lt;int&gt;,
## #   body_mass_g &lt;int&gt;</code></pre>
</div>
<div id="transforming-from-wide-to-long" class="section level2">
<h2>4. Transforming from wide to long</h2>
<p>The <code>penguins</code> dataset is clearly in a wide form, as it gives multiple observations across the columns. For many reasons we may want to transform data from wide to long. In long data, each observation has its own row. The older function <code>gather()</code> in <code>tidyr</code> was popular for this sort of task but its new version <code>pivot_longer()</code> is even more powerful. In this case we have different body parts, measures and units inside these column names, but we can break them out very simply like this:</p>
<pre class="r"><code>penguins_long &lt;- penguins_id %&gt;% 
  tidyr::pivot_longer(contains(&quot;_&quot;), # break out the measurement cols
                      names_to = c(&quot;part&quot;, &quot;measure&quot;, &quot;unit&quot;), # break them into these three columns
                      names_sep = &quot;_&quot;) #  use the underscore to separate

penguins_long</code></pre>
<pre><code>## # A tibble: 1,368 x 9
## # Groups:   species, island, sex, year [35]
##    species island    sex     year studygroupid part    measure unit   value
##    &lt;fct&gt;   &lt;fct&gt;     &lt;fct&gt;  &lt;int&gt;        &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;  &lt;dbl&gt;
##  1 Adelie  Torgersen male    2007            1 bill    length  mm      39.1
##  2 Adelie  Torgersen male    2007            1 bill    depth   mm      18.7
##  3 Adelie  Torgersen male    2007            1 flipper length  mm     181  
##  4 Adelie  Torgersen male    2007            1 body    mass    g     3750  
##  5 Adelie  Torgersen female  2007            1 bill    length  mm      39.5
##  6 Adelie  Torgersen female  2007            1 bill    depth   mm      17.4
##  7 Adelie  Torgersen female  2007            1 flipper length  mm     186  
##  8 Adelie  Torgersen female  2007            1 body    mass    g     3800  
##  9 Adelie  Torgersen female  2007            2 bill    length  mm      40.3
## 10 Adelie  Torgersen female  2007            2 bill    depth   mm      18  
## # ... with 1,358 more rows</code></pre>
</div>
<div id="transforming-from-long-to-wide" class="section level2">
<h2>5. Transforming from long to wide</h2>
<p>It’s just as easy to move back from long to wide. <code>pivot_wider()</code> gives much more flexibility compared to the older <code>spread()</code>:</p>
<pre class="r"><code>penguins_wide &lt;- penguins_long %&gt;% 
  tidyr::pivot_wider(names_from = c(&quot;part&quot;, &quot;measure&quot;, &quot;unit&quot;), # pivot these columns
                     values_from = &quot;value&quot;, # take the values from here
                     names_sep = &quot;_&quot;) # combine col names using an underscore

penguins_wide</code></pre>
<pre><code>## # A tibble: 342 x 9
## # Groups:   species, island, sex, year [35]
##    species island sex    year studygroupid bill_length_mm bill_depth_mm
##    &lt;fct&gt;   &lt;fct&gt;  &lt;fct&gt; &lt;int&gt;        &lt;int&gt;          &lt;dbl&gt;         &lt;dbl&gt;
##  1 Adelie  Torge~ male   2007            1           39.1          18.7
##  2 Adelie  Torge~ fema~  2007            1           39.5          17.4
##  3 Adelie  Torge~ fema~  2007            2           40.3          18  
##  4 Adelie  Torge~ fema~  2007            3           36.7          19.3
##  5 Adelie  Torge~ male   2007            2           39.3          20.6
##  6 Adelie  Torge~ fema~  2007            4           38.9          17.8
##  7 Adelie  Torge~ male   2007            3           39.2          19.6
##  8 Adelie  Torge~ &lt;NA&gt;   2007            1           34.1          18.1
##  9 Adelie  Torge~ &lt;NA&gt;   2007            2           42            20.2
## 10 Adelie  Torge~ &lt;NA&gt;   2007            3           37.8          17.1
## # ... with 332 more rows, and 2 more variables: flipper_length_mm &lt;dbl&gt;,
## #   body_mass_g &lt;dbl&gt;</code></pre>
</div>
<div id="running-group-statistics-across-multiple-columns" class="section level2">
<h2>6. Running group statistics across multiple columns</h2>
<p><code>dplyr</code> can how apply multiple summary functions to grouped data using the <code>across</code> adverb, helping you be more efficient. If we wanted to summarize all bill and flipper measurements in our penguins we would do this:</p>
<pre class="r"><code>penguin_stats &lt;- penguins %&gt;% 
  dplyr::group_by(species) %&gt;% 
  dplyr::summarize(across(ends_with(&quot;mm&quot;), # do this for any column ending in mm
                          list(~mean(.x, na.rm = TRUE), ~sd(.x, na.rm = TRUE)))) # calculate a mean and sd</code></pre>
<pre><code>## `summarise()` ungrouping output (override with `.groups` argument)</code></pre>
<pre class="r"><code>penguin_stats</code></pre>
<pre><code>## # A tibble: 3 x 7
##   species bill_length_mm_1 bill_length_mm_2 bill_depth_mm_1 bill_depth_mm_2
##   &lt;fct&gt;              &lt;dbl&gt;            &lt;dbl&gt;           &lt;dbl&gt;           &lt;dbl&gt;
## 1 Adelie              38.8             2.66            18.3           1.22 
## 2 Chinst~             48.8             3.34            18.4           1.14 
## 3 Gentoo              47.5             3.08            15.0           0.981
## # ... with 2 more variables: flipper_length_mm_1 &lt;dbl&gt;,
## #   flipper_length_mm_2 &lt;dbl&gt;</code></pre>
</div>
<div id="control-how-output-columns-are-named-when-summarising-across-multiple-columns" class="section level2">
<h2>7. Control how output columns are named when summarising across multiple columns</h2>
<p>The columns in <code>penguin_stats</code> have been given default names which are not that intuitive. If we name our summary functions, we can then use the <code>.names</code> argument to control precisely how we want these columns named. This uses <code>glue</code> notation. For example, here we want to construct the new column names by taking the existing column names, removing any underscores or ‘mm’ metrics, and pasting to the summary function name using an underscore:</p>
<pre class="r"><code>penguin_stats &lt;- penguins %&gt;% 
  dplyr::group_by(species) %&gt;% 
  dplyr::summarize(across(ends_with(&quot;mm&quot;), 
                          list(mean = ~mean(.x, na.rm = TRUE), sd = ~sd(.x, na.rm = TRUE)), # name summary functions
                          .names = &quot;{gsub(&#39;_|_mm&#39;, &#39;&#39;, col)}_{fn}&quot;)) # structure for summarized column names</code></pre>
<pre><code>## `summarise()` ungrouping output (override with `.groups` argument)</code></pre>
<pre class="r"><code>penguin_stats</code></pre>
<pre><code>## # A tibble: 3 x 7
##   species billlength_mean billlength_sd billdepth_mean billdepth_sd
##   &lt;fct&gt;             &lt;dbl&gt;         &lt;dbl&gt;          &lt;dbl&gt;        &lt;dbl&gt;
## 1 Adelie             38.8          2.66           18.3        1.22 
## 2 Chinst~            48.8          3.34           18.4        1.14 
## 3 Gentoo             47.5          3.08           15.0        0.981
## # ... with 2 more variables: flipperlength_mean &lt;dbl&gt;, flipperlength_sd &lt;dbl&gt;</code></pre>
</div>
<div id="running-models-across-subsets" class="section level2">
<h2>8. Running models across subsets</h2>
<p>The output of <code>summarize()</code> can now be literally anything, because <code>dplyr</code> now allows different column types. We can generate summary vectors, dataframes or other objects like models or graphs.</p>
<p>If we wanted to run a model for each species you could do it like this:</p>
<pre class="r"><code>penguin_models &lt;- penguins %&gt;% 
  dplyr::group_by(species) %&gt;% 
  dplyr::summarize(model = list(lm(body_mass_g ~ flipper_length_mm + bill_length_mm + bill_depth_mm)))  # store models in a list column</code></pre>
<pre><code>## `summarise()` ungrouping output (override with `.groups` argument)</code></pre>
<pre class="r"><code>penguin_models</code></pre>
<pre><code>## # A tibble: 3 x 2
##   species   model 
##   &lt;fct&gt;     &lt;list&gt;
## 1 Adelie    &lt;lm&gt;  
## 2 Chinstrap &lt;lm&gt;  
## 3 Gentoo    &lt;lm&gt;</code></pre>
<p>It’s not usually that useful to keep model objects in a dataframe, but we could use other tidy-oriented packages to summarize the statistics of the models and return them all as nicely integrated dataframes:</p>
<pre class="r"><code>library(broom)

penguin_models &lt;- penguins %&gt;% 
  dplyr::group_by(species) %&gt;% 
  dplyr::summarize(broom::glance(lm(body_mass_g ~ flipper_length_mm + bill_length_mm + bill_depth_mm))) # summarize model stats</code></pre>
<pre><code>## `summarise()` ungrouping output (override with `.groups` argument)</code></pre>
<pre class="r"><code>penguin_models</code></pre>
<pre><code>## # A tibble: 3 x 13
##   species r.squared adj.r.squared sigma statistic  p.value    df logLik   AIC
##   &lt;fct&gt;       &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;
## 1 Adelie      0.508         0.498  325.      50.6 1.55e-22     3 -1086. 2181.
## 2 Chinst~     0.504         0.481  277.      21.7 8.48e-10     3  -477.  964.
## 3 Gentoo      0.625         0.615  313.      66.0 3.39e-25     3  -879. 1768.
## # ... with 4 more variables: BIC &lt;dbl&gt;, deviance &lt;dbl&gt;, df.residual &lt;int&gt;,
## #   nobs &lt;int&gt;</code></pre>
</div>
<div id="nesting-data" class="section level2">
<h2>9. Nesting data</h2>
<p>Often we have to work with subsets, and it can be useful to apply a common function across all subsets of the data. For example, maybe we want to take a look at our different species of penguins and make some different graphs of them. Grouping based on subsets would previously be achieved by the following somewhat awkward combination of <code>tidyverse</code> functions.</p>
<pre class="r"><code>penguins %&gt;% 
  dplyr::group_by(species) %&gt;% 
  tidyr::nest() %&gt;% 
  dplyr::rowwise()</code></pre>
<pre><code>## # A tibble: 3 x 2
## # Rowwise:  species
##   species   data              
##   &lt;fct&gt;     &lt;list&gt;            
## 1 Adelie    &lt;tibble [151 x 7]&gt;
## 2 Gentoo    &lt;tibble [123 x 7]&gt;
## 3 Chinstrap &lt;tibble [68 x 7]&gt;</code></pre>
<p>The new function <code>nest_by()</code> provides a more intuitive way to do the same thing:</p>
<pre class="r"><code>penguins %&gt;% 
  nest_by(species)</code></pre>
<pre><code>## # A tibble: 3 x 2
## # Rowwise:  species
##   species                 data
##   &lt;fct&gt;     &lt;list&lt;tbl_df[,7]&gt;&gt;
## 1 Adelie             [151 x 7]
## 2 Chinstrap           [68 x 7]
## 3 Gentoo             [123 x 7]</code></pre>
<p>The nested data will be stored in a column called <code>data</code> unless we specify otherwise using a <code>.key</code> argument.</p>
</div>
<div id="graphing-across-subsets" class="section level2">
<h2>10. Graphing across subsets</h2>
<p>Armed with <code>nest_by()</code> and the fact that we can summarize or mutate virtually any type of object now, this allows us to generate graphs across subsets and store them in a dataframe for later use. Let’s scatter plot bill length and depth for our three penguin species:</p>
<pre class="r"><code># generic function for generating a simple scatter plot in ggplot2
scatter_fn &lt;- function(df, col1, col2, title) {
  df %&gt;% 
    ggplot2::ggplot(aes(x = {{col1}}, y = {{col2}})) +
    ggplot2::geom_point() +
    ggplot2::geom_smooth(method = &quot;loess&quot;, formula = &quot;y ~ x&quot;) +
    ggplot2::labs(title = title)
}

# run function across species and store plots in a list column
penguin_scatters &lt;- penguins %&gt;% 
  dplyr::nest_by(species) %&gt;% 
  dplyr::mutate(plot = list(scatter_fn(data, bill_length_mm, bill_depth_mm, species))) 

penguin_scatters</code></pre>
<pre><code>## # A tibble: 3 x 3
## # Rowwise:  species
##   species                 data plot  
##   &lt;fct&gt;     &lt;list&lt;tbl_df[,7]&gt;&gt; &lt;list&gt;
## 1 Adelie             [151 x 7] &lt;gg&gt;  
## 2 Chinstrap           [68 x 7] &lt;gg&gt;  
## 3 Gentoo             [123 x 7] &lt;gg&gt;</code></pre>
<p>Now we can easily display the different scatter plots to show, for example, that our penguins exemplify <a href="https://en.wikipedia.org/wiki/Simpson%27s_paradox">Simpson’s Paradox</a>:</p>
<pre class="r"><code>library(patchwork)

# generate scatter for entire dataset
p_all &lt;- scatter_fn(penguins, bill_length_mm, bill_depth_mm, &quot;All Species&quot;) 

# get species scatters from penguin_scatters dataframe
for (i in 1:3) {
 assign(paste(&quot;p&quot;, i, sep = &quot;_&quot;),
        penguin_scatters$plot[i][[1]]) 
}

# display nicely using patchwork in R Markdown
p_all /
(p_1 | p_2 | p_3) +
  plot_annotation(caption = &quot;{palmerpenguins} dataset&quot;)</code></pre>
<p><img src="/post/dplyr_updates/index_files/figure-html/unnamed-chunk-13-1.jpeg" width="100%" /></p>
<blockquote>
<p>Inspired by Keith McNulty’s post <a href="https://towardsdatascience.com/ten-up-to-date-ways-to-do-common-data-tasks-in-r-4f15e56c92d">here</a></p>
</blockquote>
<hr />
<div id="did-you-find-this-page-helpful-consider-sharing-it" class="section level3">
<h3>Did you find this page helpful? Consider sharing it 🙌</h3>
</div>
</div>
